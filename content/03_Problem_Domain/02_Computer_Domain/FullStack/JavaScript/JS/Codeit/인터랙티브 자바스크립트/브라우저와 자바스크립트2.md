## 요소 노드 프로퍼티
```js
const myTag = document.querySelector('#list-1');

//innerHTML
console.log(myTag.innerHTML)
// 요소안에 있는 내용을 문자열로 리턴해준다.
// 다만, 태그안에 줄바꿈이나 들여쓰기도 모두포함된다.
// innerHTML은 요소안에 내용들을 수정할때 자주사용된다.
myTag.innerHTML = '<li>Exotic</li>'
// 이런식으로 해당문자열로 완전 수정되는것이다.

//outerHTML
console.log(myTag.outerHTML)
// 해당 코드를 포함한 HTML을 전부 출력해준다.
// outerHTML에 값을 넣으면 처음에 있던 요소는 사라진다는점이다.!
myTag.outerHTML = '<ul id="new-list"><li>Exotic</li></ul>'

//textContent
console.log(myTag.textContent);
//html요소들을 제외한 텍스트 노드들만 가져옵니다.
myTag.textContent = 'new text';
// innerHTML과 마찬가지로 값이 완전수정되었다. (특수문자도 텍스트로 처리해버린다.)
//즉,<li>...</li>하더라도 해당 <><>부분을 그대로 웹에 출력해버린다.
// 원하지 않는 HTML코드가 추가되는것을 방지할수도있겠죠
```

### **innerHTML vs outerHTML**
innerHTML: 요소노드의 내부코드를 수정할 때 사용한다.( 태그들끼리 줄 바꿈이나, 들여쓰기, 띄어쓰기 그런 부분들도 모두포함)
outerHTML: 요소노드의 코드 전체를 수정할 때 사용된다.(당연히 외부 전체를 사용하니 해당 요소도 바뀔수있다는것)

## 요소 노드 추가하기
```js
const today = document.querySelector('#today');
today.innerHTML = '<ul>처음</ul>' + todat.innerHTML;
today.innerHTML = today.innerHTML + '<li>마지막</li>';

const newToday = document.querySelector('#today');
newToday.outerHTML = newToday.outerHTML + '<p>다음</p>';

// 이러한 프로퍼티들을 사용하면 값을 요소를 바꾸고 날라가지않고 추가하기위해선 위코드처럼 넣어야하지만, 너무 많기도하고(완전히 새로운 요소로된다.)
//>덮어쓰는 방식
```

```js
const tomorrow = document.querySelector('#tomorrow');
//1. 요소 노드 만들기: document.createElement('태그이름')
const first = document.createElement('li');

//2. 요소 노드 꾸미기: textContent, innerHTML, ...
first.textContent = '처음';

// 3. 요소 노드 추가하기: NODE.prepend, append, after, before
// append는 대상을 노드의 마지막에 삽입을 하게되고
// prepend는 대상을 노드의 가장 앞에 삽입을 하게된다.
// before는 대상을 노드이전에 삽입해주고
// after는 대상을 노드 다음에 삽입해준다.
tomorrow.prepend(first);

//...

const last = document.createElement('li');
last.textContent = '마지막';
tomorrow.append(last);

const prev = document.createElement('p');
prev.textConent = '이전';
tomorrow.before(prev);
// tomorrow.before('string')
// 이렇게 바로 문자열을 넣을수있고
// tomorrow. before('string', prev)
//이런식으로 여러값을 넣을수있다.

const next = document.createElement('p');
next.textConent = '다음';
tomorrow.after(next);

//before,after은 형제노드로 추가해준다.

```

## 노드 삭제와 이동하기
```js
const today = document.querySelector('#today')
const tomorrow = document.querySelector('#tomorrow')

// 노드 이동하기: prepend, append, before, after
today.append(tomorrow.children[1]);
// 아래와 같이 다양한 방법으로 이동시킬수있다.
tomorrow.children[1].after(today.children[1]);
tomorrow.children[2].before(today.childrem[1]);
tomorrow.lastElementChild.before(today.children[1]
)

// 노드 삭제하기: Node.remove()
tomorrow.remove();
//remove를 하면 바로 지워지지않는다.
```

## HTML 속성 다루기
```js
// HTML 속성 (HTML attribute)
const tomorrow = document.querySelector('#tomorrow');
const item = tomorrow.firstElementChild;
const link = item.firstElementChild;

// id 속성
console.log(tomorrow);
console.log(tomorrow.id);

// class 속성
// className으로 변한다는것을 주의한다.
console.log(item);
console.log(item.className);

// href 속성
console.log(link);
console.log(link.href);
console.log(tomorrow.href);

/** 
* 표준 html속성이 아닌경우 undefined
* 예를들어 ol에 href를 넣는경우 이러한 속성이없을때
* 그리고 대소문자를 구분하지 않는다.
* HRef -> 소문자로 변환시켜줌 -> href
*/

// elem.getAttribute('속성'): 속성에 접근하기
// 표준과 비표준 상관없이 해당 요소를 출력해준다.
// className과 'class'를 혼동하지 않도록 주의한다.
console.log(tomorrow.getAttribute('href'));
console.log(item.getAttribute('class'))

// elem.setAttribute('속성','값'): 속성 추가(수정)하기
tomorrow.setAttribute('class','list'); //추가
link.setAttribute('href','https://www.codeit.kr');//수정

// elem.removeAttribute('속성'): 속성 제거
tomorrow.removeAttribute('href');
tomorrow.removeAttribute('class');
```

## 스타일 다루기
```js
// style property
today.children[0].style.textDecoration = 'line-through';
// today.childerm[0].style.text-decoration = 'line-through'(x)
//카멜표기법을 사용해야한다.
```
이렇게되면 인라인으로 속성이들어가기에 우선순위가 높아지기도하며, 다른 비슷한 코드를 여러번사용하는 불필요한작업이 들어갈수있다.
> 그래서 자바스크립트에서는 스타일을 다루는것보다 클래스를 다루는것을 추천한다.

1.
```CSS
.done {
	opacity: 0.5;
	text-decoration: line-through;
}
```
```js
// elem.className
today.children[1].className = 'done';
// 다만 해당 자식의 클래스가 done으로 완전바껴버린다.
// 이런식일때는 classList
// elem.classList: add, remove, toggle
console.log(today.classList);
console.log(today.children[1].classList);

const item = tomorrow.children[1];
item.classList.add('done','other');
// item.classList.add('done','other'); 이렇게 중복되어도 하나만 적용된다.
item.classList.remove('done','other');
// 삭제도 콤마를 기준으로 여러 속성을 삭제할수있다.

// 토글은 두번제 코드에서는 불리언값을 넣을수있다
// 트루시 클래스를 넣고, 폴스시 클래스를 뺸다.
item.classList.toggle('done', boolean);
```

## 비표준 속성 다루기


1. 선택자로 활용
```js
/** 대괄호를 이요하면 대괄호 안에 있는 속성이름 */
// [속성이름 = "값"]처럼 작성하면, 좀 더 구체적으로 속성이름에 값을 가진 태그들을 선택할수있다. 
const field = document.querySelectorAll('[field]');
console.log(fields);
```
![[Pasted image 20250818130915.png]]
2. 값을 표시할 태그를 구분할 때 활용
```js
const fields = document.querySelectorAll('[field]');
const task = {
  title: '코드 에디터 개발',
  manager: 'CastleRing, Raccoon Lee',
  status: '',
};

for (let tag of fields) {
  const field = tag.getAttribute('field');
  tag.textContent = task[field];
}

``` 
![[Pasted image 20250818131308.png]]
3. dataset 프로퍼티
비표준 속성을 사용하기 위해 미리 약속된 방식이 존재하는데요. 바로 `data-*` 속성입니다.

`data-`로 시작하는 속성은 모두 dataset이라는 프로퍼티에 저장되는데요. 예를 들어서 `data-status`라는 속성이 있다면, `element.dataset.status`라는 프로퍼티에 접근해서 그 값을 가져올 수 있는 것이죠.
```CSS
[data-status] {
  padding: 5px 10px;
}

[data-status="대기중"] {
  background-color: #FF6767;
  color: #FFFFFF;
}

[data-status="진행중"] {
  background-color: #5f62ff;
  color: #FFFFFF;
}

[data-status="완료"] {
  background-color: #07c456;
  color: #FFFFFF;
}
/*여기서 field 와 status 는 사용자가 정한 비표준 속성이기 때문에

언어 그대로 해석을 하시면 될거에용

정해진 기능과 역할이 있다기 보다는,

사용자가 비표준 속성을 통해 요소를 다루기 쉽게 하기 위해 쓰신다고 보면 될거에용*/
```
```JS
const fields = document.querySelectorAll('[data-field]');
const task = {
  title: '코드 에디터 개발',
  manager: 'CastleRing, Raccoon Lee',
  status: '',
};

for (let tag of fields) {
  const field = tag.dataset.field;
  tag.textContent = task[field];
}

const btns = document.querySelectorAll('.btn');
for (let btn of btns) {
  const status = btn.dataset.status;
  btn.onclick = function () {
    fields[2].textContent = status;
    fields[2].dataset.status = status;
  };
}
// 조금 더 안전하게 비표준 속성을 활용할 수 있습니다.
```
사실 비표준 속성을 활용하는 것은 개발자의 선택적인 부분입니다. 반드시 비표준 속성을 활용해야만 하는 상황은 아마 없을지도 모릅니다. 하지만 상황에 따라서 비표준 속성이 필요할 수도 있고 혹은 비표준 속성을 활용하는 것이 조금 더 효율적일 수도 있으니 다양한 상황들을 고려해서, 만약 비표준 속성을 활용해야 한다면 `data-*`형태와 `dataset`프로퍼티를 사용하는 것이 조금 더 안전하다는 점도 꼭 잊지 말고 기억해두시면 좋을 것 같습니다.