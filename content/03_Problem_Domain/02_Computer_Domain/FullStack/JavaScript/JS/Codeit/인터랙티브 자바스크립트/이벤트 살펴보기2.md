## capturing
표준 DOM 이벤트 흐름
1. 캡처링 단계: 이벤트가 하위 요소로 전파되는 단계
2. 타깃 단계: 이벤트가 실제 타깃 요소에 전달되는 단계
3. 버블링 단계: 이벤트가 상위 요소로 전파되는 단계

taget은 타깃 단계 프로퍼티가 되는 요소에 등록되어 있던 이벤트 핸들러가 동작하는 단계, 쉽게 생각해 **가장 먼저 처음 이벤트 핸들러가 동작하게 되는 순간**

### **캡처링이란?**
```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8">
    <title>JS with Codeit</title>
  </head>
  <body>
    <div id="content">
      <h1 id="title">오늘 할 일</h1>
      <ol id="list">
        <li class="item">자바스크립트 공부</li>
        <li class="item">독서</li>
      </ol>
    </div>
    <script src="index.js"></script>
  </body>
</html>
// li > ol > body > html > document > window객체로 이벤트가 전달되는것을 버블링이라고했다.
```
> 캡처링은 이벤트가 발생하면 가장 먼저, 그리고 버블링의 반대 방향으로 진행되는 이벤트 전파 방식이다.

![[Pasted image 20250818150845.png]]

이벤트가 발생하면 가장 먼저 window 객체에서 target 까지 이벤트 전파가 일어난다.(캡처링 단계)
타깃에 도달하면 타깃에 등록된 이벤트가 동작하고(동작단계)
이후 다시 window객체로 이벤트가 전파된다.(버블링 단계)
> 회의에서 발언권이 내려갔다가 -> 발언자가 말하고 -> 다시 위로 보고하는 버블링 절차이다.

캡처링 단계에서 이벤트를 발생 시켜야 하는일은 드물다 보통 타깃(해당 이벤트핸들러가)먼저 동작한 후버블링 단계에서 각 부모 요소에 이벤트 핸들러가 있으면 그때 해당 이벤트 핸들러가 동작하는것이 일반적 (높은 직군에서 기회를 줘서 맗해야하는 경우보다 나중에 결제하는게 많다...는 느낌)

상황에 따라서는 캡처링 단계에서 동작시켜야되는데 `addEventListener`에 3번째 프로퍼티에 true또는 {capture:true}를 전달하면 된다.
```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8">
    <title>Codeit Acid Rain</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div>DIV
      <ul>UL
        <li>LI</li>
      </ul>
    </div>  
    <script>
      for (let elem of document.querySelectorAll('*')) {
        elem.addEventListener("click", e => alert(`캡쳐링 단계: ${elem.tagName}`), true);
        elem.addEventListener("click", e => alert(`버블링 단계: ${elem.tagName}`));
      }
    </script>
  </body>
</html>

body * {
  margin: 10px;
  padding: 10px;
  background-color: rgba(150, 0, 255, 0.15);
}

```
> 이벤트가 발생한 타겟에 초점을 맞춘다.

## 이벤트 위임 (Event Delegation)
```js
const list = document.querySelector('#list')

for (let item of list.children) {
	item.addEventListener('click', function(e) {
		e.target.classList.toggle('done')
	});
}
// 여기까지는 문제가없다

//아래 처럼 li요소를 추가할때 추가한 요소들은 toggle이 먹히지않는다.
const li = document.createElement('li');
li.classList.add('item');
li.textContent = '일기 쓰기';
list.append(li);
...

// 이렇게 부모 요소의 리스트에 이벤트리스너를 걸어주면된다.
// 이렇게 부모 요소에 거는것을 가리켜서 **이벤트 위임**이라고 한다.
// 자식 요소의 이벤트를 부모 이벤트에 위임해준다는것이다.
// 다만 부모에게 이벤트를 위임했기에 다른 빈공간을 클릭시 토글이 걸릴수있으니 한번더 자세하게 처리를 해줘야한다.
list.addEventListener('click',function(e) {
	e.target.classList.toggle('done');

	// 아래처럼 if문 contain등등을 활용하여 명확히 지정해줄수있다.
	// tagName: 해당 태그가 대문자 LI인경우
	// contain: 해당 속성의 클래스이름이 item인경우
	// if (e.target.tagName == 'LI')
	
	// if (e.target.classList.contain('item')) {
	// e.target.classList.toggle('done')
	//}
})
```
> 자식요소를 신경안써도 되기에 코드를 더 유연하게 작성할수있다는 장점이있다. (버블링을 사용한다.)
> 만약 자식요소중에 li.addEventListener('click'. function(e) {
> 	e.stopPropagation() 처럼 버블링을 막는 요소가있을경우
> })
> 부모로 이벤트 위임이 막혀버릴수있다는점
> 그래서 이벤트 버블링을 막는것을 피하라는것

