## 마우스 버튼 이벤트
0: 왼쪽 버튼
1: 마우스 휠
2: 마우스 오른쪽 버튼

click: 왼버튼 눌렀을때
contextmenu: 오른쪽 버튼눌렀을때
dblclick: 동일한 위치에서 빠른 두번클릭

mousedown: 마우스 버튼을 누른 순간
mouseup: 마우스 버튼을 눌렀다 땐 순간
> 이런식으로 좀더 세밀하게 이벤트를 만질수있겠죠

이벤트가 하나만 작동하는것이아니라 여러 이벤트가 들어갈수있다. 즉 (왼클릭시 mousedown,mouseup,click이라는 3개의 이벤트가 동작한다는 것이다.)
더블클릭 이벤트는 위3동작이 2번일어나고 마지막에 dblclick이 찍히는것이다.(이럴땐 총7개의 이벤트가 발생한것)
>이는 실수를 유발하는데 click이벤트가 2번 일어나는것을 모르고 dblclick을쓸때

다만 오른쪽클릭은 운영체제마다다르다.
moundown, contextmenu, mounsup 순(맥,윈도우는 정방향)
또 컨텍스트가 뜬상태면 mouseup이 뜨지않을수있다.

## 마우스 이동 이벤트
mousemove: 마우스 포인터가 이동할 때
mouseover: 마우스 포인터가 요소 밖으로 안으로 이동할 때
mouseout: 마우스 포인터가 요소안에서 밖으로 이동할 때
```js
/* 요소 위를 지나갈때마다 콘솔이 찍히는 코드 */
const box = document.querySelector('#box1');

function onMounseMove() {
	console.log('mouse is moving!')
}

// 이러한 마우스움직임은 위치기반으로 쓸때많이서 사용한다.
box1.addEventListener('mousemove', onMouseMove)

/**
	MouseEvent.clicentX. clientY
	MouseEvent.pageX, pageY
	MouseEvent.offsetX, offsetY
*/
function onMouseMove(e) {
/** 상단의 모서리 위치르르 (0,0)으로 계산한다. */
	//client는 보이는 화면에서의 위치값
	console.log(`${e.clientX},${e.clientY}`)
	//page는 전체페이지기준에서 위치값
	console.log(`${e.pageX},${e.pageY}`)
	//offset은 이벤트가 발생한 요소내에서 위치
	console.log(`${e.offsetX}, ${e.offsetY}`)
	// 자동화를 할때 웹에서 좌표를 찍어 마우스를 이동시킬수있겠죠
}
```
![[Pasted image 20250818170725.png]]

## 마우스 이동 이벤트 2
mousemove: 마우스 포인터가 이동할 때
mouseover: 마우스 포인터가 요소 밖에서 안으로 이동할때
mouseout: 마우스 포인터가 요소 안에서 밖으로 이동할때

버블링에 의해서 자식요소도 핸들링이 된다.
토클과 연동해서 들어갈때와 나갈때 스타일링을 해줘서 ux를 개선할수있다.
```js
/**
	MouseEvent.target: 이벤트가 발생한 요소
	MouseEvent.relatedTarget: 이벤트가 발생하기 직전(또는 직후)에 마우스가 위치해 있던 요소
*/

function printEventData(e) {
	if(e.target.classList.contain('cell')) {
		e.target.classList.toggle('on');
	}
}
...
```

### **mouseenter/mouseleave**
mouseover/mouseout과 비슷하지만
1. 버블링이 일어나지 않는다.
2. 자식 요소의 영역을 계산하지 않는다.
	1. 자식 요소의 영역을 구분하지않기때문에 mouseenter타입으로 이벤트 핸들러가 등록된 요소에서는 자식요소에서 이벤트 핸들러가 동작하지않는 것 뿐만 아니라 자식요소에 들어갔다 나올때도 이벤트 핸들러가 동작하지않는다.