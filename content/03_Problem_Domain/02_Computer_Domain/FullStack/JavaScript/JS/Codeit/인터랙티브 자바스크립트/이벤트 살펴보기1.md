## 이벤트 핸들러 등록하기
```js
// elem.addEventListener(event, handler)
// 이벤트리스너 를 사용할때 가장 권장되는방법이다.
// 하나의 이벤트리스터 각각을 설정할수있는방법이다.
btn.addEventListener('click', event1);
btn.addEventListener('click', event2);
// elem.removeEventListenr(event, handler)
// 삭제할때는 등록해준 핸들러그대로 넣어줘야합니다.
// 그리고 주의할점이 event2()이런식으로 말고 함수이름을 그대로 쓰는게 관례이다.
btn.removeEventListener('click', event2);
```

### **마우스 이벤트**
mousedown: 마우스 버튼을 누르는 순간
mouseup: 마우스 버튼을 눌렀다 떼는 순간
click: 왼쪽 버튼을 클릭한 순간
dblclick: 더블클릭
contextmenu: 오른쪽버튼을 클릭한 순간
mousemove: 마우스를 움직이는 순간
mouseover: 마우스 포인터가 요소 위로 올라온 순간
mouseout: 요소에서 벗어나는 순간
mouseenter: 마우스 포인터가 요소 위로 올라온 순간(버블링x)
mouseleave: 요소에서 벗어나는 순간 (버블링x)

### **키보드 이벤트**
keydown: 키보드의 버튼을 누르는 순간
keypress: 키보드의 버튼을 누르는 순간(출력가능한 키에,shift,esc는 작동하지않음)
keyup: 키보드의 버튼을 눌렀다 떼는 순간

### **포커스 이벤트**
focusin: 요소에 포커스가 되는 순간
focusout: 포커스가 빠져나가는 순간
focus: 포커스가 되는순간(버블링x)
blur: 포커스가 빠져나가는 순간 (버블링x)

### **입력 이벤트**
change: 입력된 값이 바뀌는 순간
input: 값이 입력되는 순간
select: 입력 양식의 하나가 선택되는 순간
submit: 폼을 전송하는 순간

### **스크롤 이벤트**
scroll: 스크롤바가 움직일 때

### **윈도우 창 이벤트**
resize: 윈도우 사이즈를 움직일때 발생

---
## 이벤트 객체
### **공통 프로퍼티**
이벤트 타입과 상관없이 모든 이벤트 객체들이 공통적으로 가지는 프로퍼티이다.
type: 이벤트 이름('click','mouseup','keydown' 등)
target: 이벤트가 발생한 요소
currentTarget: 이벤트 핸들러가 등록된 요소
timeStamp: 이벤트 발생 시각(페이지가 로드된 이후부터 경과한 밀리초)
bubbles: 버블링 단계인지를 판단하는 값

### **마우스 이벤트**
button: 누른 마우스의 버튼(0:왼쪽,1:가운데(휠),2:오른쪽)
clientX, clientY: 마우스 커서의 브라우저 표시 영역에서의 위치
pageX, pageY: 마우스 커서의 문서 영역에서의 위치
offsetX, offsetY: 이벤트 발생한 요소에서의 위치
screenX, screenY: 모니터 화면 영역에서의 위치
altKey: 이벤트가 발생할 때 alt키를 눌렀는지
ctrlKey: 이벤트가 발생할 때 ctrl키를 눌렀는지
shiftKey: 이벤트가 발생할 때 shift키를 눌렀는지
metaKey: meta키를 눌렀는지

### **키보드 이벤트**
key: 누른 키가 가지고 있는 값
code: 누른 키의 물리적인 위치
altKey: 이벤트가 발생할 때 alt키를 눌렀는지
ctrlKey: ...
shiftKey:...
metaKey: ...

## 이벤트 버블링 (Event Bubbling)
해당요소의 상위의 요소까지 올라가면서 최종적으로 글로벌객체인(window)까지 올라갑니다.(요소 각각에 있는 이벤트핸들러가 작동되는 원리이다.)
```js
content.addEventListener('click', function(e) {
	console.log('content Event');
	console.log(e.currentTarget);
});
title.addEventListener('click', function(e) {
	console.log('content Event');
	console.log(e.currentTarget);
});
list.addEventListener('click', function(e) {
	console.log('content Event');
	console.log(e.currentTarget);
});
```

타겟위치(e.target)는 바뀌지않습니다. 그렇기에 부모요소에서 이벤트가 발생한 위치를 찾을수있게 해줍니다. 버블링이일어나도 타겟객체의 변하지않고 버블링이 일어난 시작지점을 나타낸다는점

e.currentTarget은 실제작동하는 요소에 접근할수있다.

```js
for (let item of items) {
	item.addEventListener('click', function(e) {
		console.log('item Event');
		console.log(e.currenTarget);
		e.stopPropagation();//버블링을 금지할수있다.	
	})
}
// 버블링은 왠만하면 막지않는것을 추천한다.
// 버블링이 막히면 DOM에서 해당 이벤트를 DOM에서 생성하지 못하기에 원하는 이벤트결과값을 얻지못한다.
// 잘 코드를짠다면 버블링금지를 사용할일이 거의없다.
```
>만약 버블링을 막지 않는다면 좋아요를 누를때마다 질문도 같이 접히고, 펼쳐질 것입니다:)


