## 추상화1
객체 지향 프로그래밍의 4가지 기둥
1. 추상화: 구체적인 존재를 원하는 방향으로 간략화하는 것
	1. 클래스의 프로퍼티와 메소드 이름이 직관적으로 이해하기 쉬워야한다.
	2. 실무에서는 코멘트와, 별도의 문서를 만들기도한다.
	3. 이러한 이름을 짓는것은 고역일수있을정도로(?)쉽지 않는일이다.
		1. 좋은 이름일 수록 나중에 코드를 해석할 때 드는 시간적인 비용이 줄어들기 때문이다.
	4. 보안적으로 uglify(변수명 바꾸기), minify(공백 없애기) 같은것을 하고 용량이 커지는 것을 막게할수있다 (특히 대기업 네이버라든가 js코드를 따보면 이런경우가 있죠)
2. 캡슐화: 객체의 특정 프로퍼티에 직접접근하지 못하게 만든것
```js
class User {
	constructor(email, birthdate){
		this.email = email;
		this.birthdate = birthdate;
	}
	buy(itme) {
		console.log(`${this.email} buys ${item.name}`);
	}

	//getter 메소드는 파라미터를 따로 써줄필요가없다.
	
	get email() {
		//return this._email;
		return `Email Address is ${this._email}`// 이렇게 문자열을 넣으수있다.
	}
	// 메소드가 실행되게 setter 메소드를 만든다.
	set email(address) {
		// 주소를 검증하는 코드가 들어갑니다.
		if(address.includes('@')){
			//만약 주소안에 '엣'이 포함된다면
			//이 이메일에 주소를 할당하라 (값에 대한 유효성검사)
			// 프로그래밍에서 숨기고자하는 맨앞에 언더바를 붙인다.
			// 에제 this.email에는 이상한 주소가 오는것을 방지할수있다.
			this._email = address;
		} else {
			throw new Error('Invalid email address');
		}
	}
}

const item = {
	name: '스웨터',
	price: 30000,
}

const user1 = new User('','');
user1.email = 'chris robert' // 실수로 이러한 것처럼 바로접근할려고 할때
// 위코드는 값에 대한 유효성검사에서 falsy하니 오류가난다.
user1.email = 'chris_robert@google.com'
//console.log(user1_email)
conosole.log(user1.email) //이제 언더바없이 해도된다. 임의이값이 씌워진게 아니기때문에

//처음 생성자에서 this.emali = email이 실행될때
// thso.email이 하단에 set email함수를 호출하게된다.
//그래서 _email의 값이 출력이된다._
```
> 객체의 자율성 보장을 위해, 객체의 내외부를 분리하기 위해 필수적임
> 객체 지향 페러다임으로 작성하다보면 거의 대부분의 코드가 캡슐화를 한다

### **클로저(Closure)**
```js
function createUser(email, birthdate) {
	let _email = email;

	const user = {
		birthdate,

		get email() {
			return _email;
		},
		set email(address) {
			if (address.includes('@')) {
				_email = address;
			} else {
				throw new Error('invalid email address);
			}
		},
	};
	
	return user;
}
```
closure란 자바스크립트에서 **어떤 함수와 그 함수가 참조할 수 있는 값들로 이루어진 환경을 하나로 묶은 것**을 의미, createUser함수가 실행되는 시점에 email이라는 getter/setter 메소드는 _email 이라는 변수의 값에 접근할 수 있는 상태
> 함수가 정의된 당시에 참조할 수 있었던 변수들을 계속 참조할 수 있는 상태의 함수를 클로저라고합니다. 이 클로저는 다른 프로그래밍 언어에서는 쉽게 찾아보기 힘든 자바스크립트만의 특징이다.

###  **메소드도 캡슐화 가능하다**
```js
function createUser(email, birthdate) {
  const _email = email;
  let _point = 0;

  function increasePoint() {
    _point += 1;
  }

  const user = {
    birthdate,

    get email() {
      return _email;
    },

    get point() {
      return _point;
    },

    buy(item) {
      console.log(`${this.email} buys ${item.name}`);
      increasePoint();
    },
  };

  return user;
}

const item = {
  name: '스웨터',
  price: 30000,
};

const user1 = createUser('chris123@google.com', '19920321');
user1.buy(item);
user1.buy(item);
user1.buy(item);
console.log(user1.point);
/**
	사용자가 물건을 살 때마다 1포인트씩 적립해 줄 목적으로 만든 변수이다.
	buy메소드를 실행할 때 그안에서 increasePoint함수도 호출해 주는것이다.
	3번 스웨터를 구입하니, 포인트는 총 3점이 쌓이게된다.
	
	여기서 중요한점은 increaePoint라는 함수가 보호받고 있는 함수이다.
	user1객체로 바로 increaePoint 함수를 호출할수없다.
	user1.increasePoint(); //user1 객체로 increasePoint직접호출
	
	>> Uncaught TypeError: user1.increasePoint is not a function
	>> 그런함수가 없다고 나온다.
*/

```
```js
/** balance라고 하는 프로퍼티에 값이 설정되는 것이 아니라 balance라고 하는 setter함수가 실행되겠죠? */
account1.balance = 값;

/** 완벽한 캡슐화라고 보기어렵다. 아래와 같은 방법으로 언제든지 _balance에 직접 접근이 가능하기 때문이다. */
account1._balance = -5000;
```
1. 상속
	1. 하나의 프로퍼티와 메소드를 다른자식에 프로퍼티와 메소드로 물려줄때 이것을 상속이라고 한다.
```js
/* 부모 클래스 */
class User {
	constructor(email, birthdate){
		this.email = email;
		this.birthdate = birthdate;
	}
	buy(itme) {
		console.log(`${this.email} buys ${item.name}`);
	}
}

/* 자식 클래스 */
// extends 로 User를 상속
// 중복되는 코드는 삭제하고 새로운 매소드와 프로퍼티를 상속받는 자식에게 추가해준다.
class PremiumUser extends User {
	construtor(email, birthdate, level) {
		this.level = level;
	}

	streamMusicForFree() {
		console.log(`Free musioc streaming for ${this.email}`);
	}
}

// >> 코드의 재사용성이 좋아진다. 

/** 다만 위코드에서 상속에서 중요한 키워드를 빼먹어서 오류가날것이다. */
// >> 자식 클래스안에서 super메소드를 호출해야한다.

	constructor(email, birthdate, level){
		super(email, birthdate) // super클래스에는 부모와 같은 생성자를 넘겨주면된다.
		this.level = level;
	}
```
1. 다형성 : 많은 형태를 갖고 있는 성질
```js
class User ... {
	...
	buy(item) {
		console.log(`${...}${...} asd`)
	}
}`

class PremiumUser extends User {
...
	buy(item){
		console.log(`${...}${...} premium_asdf `)
	}
}`

// 부모 클래스의 메소드를 자식에서 메소드의 내용을 따로 정의할때 이를 오버라이딩이라고한다.(덮어쓴다.)
// 다향성을 이용하면 다른메소드에 있는 내용을 간결하게 호출할수있다.
```
