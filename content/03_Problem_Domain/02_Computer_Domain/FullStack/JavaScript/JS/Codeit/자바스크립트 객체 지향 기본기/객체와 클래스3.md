## 부모클래스의 메소드가 필요하다면?
```js
class User ... {
	...
	buy(item) {
		console.log(`${...}${...} asd`)
	}
}`

class PremiumUser extends User {
...
	buy(item){
		super.buy(item); // 부모의 내용과 똑같은 메소득가필요하다. super이용
		this.point += item.price * 0.05;*
	}
}`
```
자식 클래스와 부모클래스를 오버라이딩할수있으며,오버라이딩 한 클래스에서 부모의 클래스의 메소드를 그대로 호출하는것도 가능하다.

## instanceof연산자
```js
const users = [user1,Puser1,user2,Puser2,user3,Puser3];

/* 이 연산자로 프리미엄 유저 객체인지 boolean값으로 표현 */
users.forEach((user) => {
	console.log(user instanceof PremiumUser) 
})

/* 자식 객체를 만든 부모 클래스도 인정이되어서 전부 truthy할것 */
users.forEach((user) => {
	console.log(user instanceof User); 
});
// instance of를 사용해 if문 분기등 조건에 사용하는것을 지향하고 하나로 합쳐서 만드는것을 추천한다.
```
![[Pasted image 20250819005334.png]]

## static프로퍼티와 static메소드
클래스에 직접적으로 딸려있는 프로퍼티와 메소드 
객체가 아닌 클래스 자체로 접근한다.!
즉 메소드가 아니라도 static 프로퍼티를 호출할수있다.
```js
class Math {
	static PI = 3.14;

	static getCircleArea(radius) {
		return Math.PI * radius * radius;
	}
}

// 이런식으로 추가가능
Math.PI = 3.141592;
Math.getRectangleArea = function (width, height) {
	return width * height;
}

// 이런식으로 호출이 가능
console.log(Math.PI);
console.log(Math.getCircleArea(5));

/* 주로 오픈소스에도 자주보임 Date내장객체에도 static이존재 */
```

## 클래스는 파일 하나당 하나씩 넣어주는 게 좋다
개발 실무에서는 이런 식으로 여러 개의 클래스를 하나의 파일에 정의하기 보다는 파일 하나당 클래스 하나를 정의해두고 이를 메인 코드에서 가져와 사용한다.
```js
class User {
  constructor(email, birthdate) {
    this.email = email;
    this.birthdate = birthdate;
  }

  buy(item) {
    console.log(`${this.email} buys ${item.name}`);
  }
} 

class PremiumUser extends User {
  constructor(email, birthdate, level, point) {
    super(email, birthdate);
    this.level = level;
    this.point = point;
  }

  buy(item) {
    console.log(`${this.email} buys ${item.name}`);  
    this.point += item.price * 0.05;
  }

  streamMusicForFree() {
    console.log(`Free music streaming for ${this.email}`);
  }
}

const item = {
  name: '스웨터', 
  price: 30000, 
};

const user1 = new User('chris123@google.com', '19920321');
const user2 = new User('rachel@google.com', '19880516');
const user3 = new User('brian@google.com', '20051125');
const pUser1 = new PremiumUser('niceguy@google.com', '19891207', 3);
const pUser2 = new PremiumUser('helloMike@google.com', '19900915', 2);
const pUser3 = new PremiumUser('aliceKim@google.com', '20010722', 5);

const users = [user1, pUser1, user2, pUser2, user3, pUser3];

users.forEach((user) => {
  user.buy(item);
});

```
이 코드를 
```js
/** User.js */
class User {
	constructor(name,email) {
		this.name = name;
		this.email = email;
	}

	buy(item) {
		console.log(`${this.email} buys ${item.name}`)
	}
}

export default User;
```
```js
import User from "./User";

/** PremiumUser.js */
class PremiumUser extends User {
	constructor(name,email,level, point) {
		super(name,email);
		this.level = level;
		this.point = point;
	}

	buy(item) {
		console.log(`${this.email} buys ${item.name}`);
		this.point += item.price * 0.05
	}

	streamMusicForFree() {
		console.log(`Free music streaming for ${this.email}`);
	}
}

export default PremiumUser;
```
```js
/** main.js */
import User from "./User";
import PremiumUser from "./PremiumUser";

const item {
	name: '스웨터',
	price: 30000,
}

const user1 = new User('chris123@google.com', '19920321');
const user2 = new User('rachel@google.com', '19880516');
const user3 = new User('brian@google.com', '20051125');
const pUser1 = new PremiumUser('niceguy@google.com', '19891207', 3); const pUser2 = new PremiumUser('helloMike@google.com', '19900915', 2); const pUser3 = new PremiumUser('aliceKim@google.com', '20010722', 5);

const users = [user1, pUser1, user2, pUser2, user3, pUser3];

users.forEach((user) => {
	user.buy(item);
});
```
> 이런식으로 각 클래스와 메인 로직을 파일별로 쪼개서  작성한다. 
> 모듈 내부의 것을 공개하고(export)
> 다른 모듈의 것을 가져오는(import)
> 실무에서는 파일 하나당 클래스 하나를 두고 외부에 공개하는 방식을 많이 사용한다.