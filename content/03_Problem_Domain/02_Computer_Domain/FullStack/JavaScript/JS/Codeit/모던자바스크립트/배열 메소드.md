## ForEach와 map

foreach는 아규먼트로 콜백 함수를 작성해주면 콜백함수의 첫번째 파라미터로 배열의 요소를 순서대로 하나씩 전달하면서 매번 이 함수를 실행하는 원리로 동작합니다. 그래서 파라미터가 하나이상이필요
for..of문과 똑같이 동작

foreach는 여기서
두번째 파라미터로 index(i)를 사용 각요소의 인덱스를 출력할수있다.
세번쨰 파리미터로 arr 파라미터로 많이 쓰는데 , 이 문법에 전달된 객체를 확인할수있다.
일반적으로 잘사용하지는 않지만 
배열에 상황에따라 필요할수는있다.

map
foreach와 똑같은데 새로운 배열이 리턴된다.  그냥 포이치는 리턴값으로 새로운 배열을 만들어주면 undefined

단순히 반복작업이면 foreach를 반복해서 새로운 배열이 필요하면 map을 사용한다.

```js
members.forEach((member) => {
	console.log(...)
	member.push('ss')// 배열길이만큼 추가되며 pop으로 배열을 줄이면 반복횟수도 줄어들기에 주의한다.
})
```

## filter와 find
필터
원하는 조건에 맞는 요소만 추려서 새로운 배열을 만들수있다.
```js
const apples = devices.filter((el) => el.brand === 'Apple')
// 콜백함수를 돌면서 트루가 되는 요소를 모아 새로운 배열로 리턴해준다.
// 리턴값이 항상 배열이기에 요소가 하나라도 하나인 배여을 리턴해주게된다.
// 그래서 만약 하나일때 스프레드 구문으로 배열을 벗겨야한다.
console.log(...apples)

// 하나일 떄는 find가 맞을수있다.(리턴값이 값)
const apples = devices.find((el) => el.name ==='Gram')
console.log(apples)
```
파인드
여러개가 아닌 유일한 하나를 찾고 싶을때 사용

차이점
리턴값이 필터는 배열, 파인드는 값이다. 그리고 하나만 찾는 파인드는 반복적으로 찾지않고 그값을 찾으면 종료된다.
즉, 파인드는 중복이 되는 요소에 맨앞에 있는 요소를 리턴해준다.
> 프로그램의 효율적인 측면에서도 중요한 내용이다.
> 존재하지 않는값을 찾는다면 undefined를 반환해준다.

## some와 every
말그대로 조금만 조건이 맞는지 모든 요소가 맞는지
filter랑 find가 있지만 요소가 단순히 불리언으로 맞는지 아닌지 판단하기위해
```js
//some: 조건을 만족하는 요소가 1개 이상 있는지 그렇다면 true
const someReturn = numbers.some((el,i) => el > 5);
//evety: 모든 요소가 조건을 만족하는지
const everyRetrun = numbers.every((el,i) => el >5);

const numbers = [] //만약 빈배열인경우
// some: false
// every: true가 리턴됨
```

## reduce
```js
/** reduce기본형 */
const numbers = [1,2,3,4]

numbers.reduce((acc, el, i, arr) => {
	return nextAccvalue;
}, initalAccValue)
/**
* acc(Accumulator): 누산기 직전에 동작한 콜백함수가 리턴한 값을 전달 받는 파라미터
* el: 배열의 요소가 전달
* idx: 배열의 인덱스가 전달
* arr: 매소드를 호출한 배열이 전달됨
*/

// 마지막에 실행되는 콜백 함수의 리턴값이 reduce리턴값이 된다.
```
reduce를 사용할때는 가급적 초깃값을 명시해 주는것이 더 안전하다.
```js
const numbers = [1,2,3,4]

const sumAll = numbers.reduce((acc, el, i) => {
	console.log(`${i}번 index의 요소로 콜백함수가 동작중입니다.`)
	console.log('acc:', acc);
	console.log('el:', el);
	console.log('--------');

	return acc + el;
},0); // 지금 함수내부가 간단해서 문제가없는데 복잡해지면 예상치 못한 결과가 나올수있기에 초깃값을 0으로 설정해준다.

console.log('sumAll:', sumAll);
```

## reduce정리
reduce매소드는 두 개의 파라미터를 활용한다. 1 파라미터는 반복 동작할 콜백 함수를 전달하고, 2는 초깃값을 전달하게 된다.
```js
function totalCareer = data.reduce((acc,el) => {
	return acc + el.month;
},0)
// 첫 번째 파라미터에 초깃값이 0으로 전달되면서 0 + el.month가 리턴되고 두 번째 반복때는 콜백 함수가 리턴한 것이 첫 번째 파라미터에 전달된다. 결국 누적합으로 리턴된다.

/** arrowfunction */
function totalCareer = data.reduce((acc,el) => acc + el.month;)
```