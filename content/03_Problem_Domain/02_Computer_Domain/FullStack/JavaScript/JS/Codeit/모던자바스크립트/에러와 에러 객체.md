## 핵심
자바스크립트에서는 에러에 name과 궻적인 에러 내용을 담고 있는 message라는 프로퍼티가존재한다. 
또한 레퍼런스에러, 타입에러, 신텍스 에러(컴파일 단계에서 잡아주기는함) 등등

실제 name과 meg맞추면 에러객체를 불러올수있다.
```js
const error = new TypeError('타입 에러가 발생');

console.log(error.name);
console.log(error.message);
//에러를 만든것이지 발생시킨것은 아니다.

throw error; //에러를 발생시킨다.
```

## try-catch
```js
try {

} catch (error) { //error라는 파라미터에 할당이되고 약자로 e를 많이쓴다.
	console.log('에러 후');
	console.error(e); //로그가아닌 실제 에러 처럼 나온다.
	console.log(e.name);
	console.log(e.message);
}
// try문에 오류가 없다면 catch문이 작동하지 않는다.
//다만 트라이내에서 에러가 터진줄 이후로는 코드가 실행되지않고 catch문이 작동되는점
```

## try-catch 할당
오류가 나오면 제일 중요한게 다음줄 부터는 실행이 되지않는다는것 하지만,
트라이-캐치로 잡아서 캐치로 오류가 발생시키면 캐치이후 코드가 실행이된다.
그래서 훨씬 더 안정적인 코드를 만들수있다는것이다.

블록스코프를 가지고있기 때문에 스코프를 신경써야합니다. try에 선언된 변수문장은 catch에서는 사용할수없다.

신텍스 에러는 코드를 실행조차하지않고 컴파일시 잡아냅니다.
이러한 에러는 예외라고 하며 이것을 처리하는것을 예외 처리(Exception)

## finally문
```js
try {
	// 실행할 코드
} catch {
	// 에러가 발생했을 때 실행할 코드
} finally {
	// 항상 실행할 코드
}
```
캐치가 작동될시 해당 코드가 모두 실행된후 다음 실행할 코드를 finally문에 작성한다.
**try문에서 어떤 코드를 실행할때 에러 여부와 상관없이 항상 실행할 코드를 작성하는것**
```js
function printMembers(...members) {
  for (const member of members) {
    console.log(member);
  }
}

try {
  printMembers('영훈', '윤수', '동욱');
} catch (err) {
  alert('에러가 발생했습니다!');
  console.error(err);
} finally {
  const end = new Date();
  const msg = `코드 실행을 완료한 시각은 ${end.toLocaleString()}입니다.`;
  console.log(msg);
}
// 에러 유무와 상관없이 코드 실행 시각을 알고 싶을때 활용가능
```
## finally문의 에러 처리는?
```js
try {
	try {
		// 실행할 코드
	} catch(err) {
		// 에러가 발생했을 때 실행할 코드
	} finally {
		// 항상 실행할 코드 finally에서도 에러시 상위 catch로
	}

} catch(err) {
	// finally문에서 에러가 발생했을 때 실행할 코드
}
```
만약 catch문에 return이있을경우 trycatch밖의 내용은 실행되지 않는다. 그때 finally를 이용해 넣어주면 return 과 상관없이 실행이된다.