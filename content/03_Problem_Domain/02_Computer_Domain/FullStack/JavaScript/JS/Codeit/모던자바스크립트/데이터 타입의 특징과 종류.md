## 핵심
기본형: Number,String,Boolean,Null,Undefined,Symbol(ES2015),BigInt(ES2020)
참조형: Object

+symbol: 유일한 값을 만들어 낼때 사용하는 타입
```JS
const user = Symbol('this is a user')
/** 다른 어떤 값과 비교해도 true가 될 수 없는 고유한 변수 */
user === 'this is user'; // false
user === 'user';// false 
user === 'Symbol'; // false
user === true; // false
user === false; // false
user === 123; // false
user === 0; // false
user === null; // false
user === undefined; // false

// 똑같은 심볼을 만들더라도 두 값을 비교시 false
const a = Symbol('this is symbol')
const b = Symbol('this is symbol')

console.log(a === b) // -> false
```
+BigInt: 엄청큰 숫자를 다룰때
- 숫자형에는 9000조 정도의 정수 표현의 한계가 존재한다.
- 만약 굉장히 정확하고 큰연산이 필요한 암호, 계산 작업시 BigInt데이터타입을 이용하면된다.
```JS
console.log(9007199254740993n); // 9007199254740993n
console.log(BigInt('9007199254740993')); // 9007199254740993n

```
> 다만 소수표현에는 사용할수없다. (syntaxError)
> 10n / 6n -> 1n 소수 형태의 결과가 리턴되는 연산은 소수점 아랫부분은 버려지고 정수 형태로 리턴됩니다.

BigInt타입끼리만 연산, 서로 다른 타입끼리는 연산은 명시적으로 타입 변환해야함
```JS
3n * 2; //typeerror
3n * 2n; //6n
Number(3n) * 2; //6
```

## typeof
```JS
typeof 'Codeit'; // string
typeof Symbol(); // symbol
typeof {}; // object
typeof []; // object
typeof true; // boolean
typeof(false); // boolean
typeof(123); // number
typeof(NaN); // number
typeof(456n); // bigint
typeof(undefined); // undefined

typeof(null) //object 문자열null이 리턴이 아닌 문자열obj
```
> 프로젝트에 버그가 생기는 우려로 null은 반영되지않는다.

```JS
function sayHi() {
	console.log('Hi!?');
}

typeof sayHi; // function
```
typeof연산자를 함수에 사용하면 obj 아닌 fuction을 반환시켜준다.