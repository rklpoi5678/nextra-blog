## 핵심
ES 2015 이전에는 var을 사용했고 이후에는 let,const가 나왔다
변수 재할당이 필요한경우는 let
변수 재할당이 필요없는경우는 const로 쓰는 방식이 좀 더 권장된다.

var은 호이스팅(Hosting) 
```js
console.log(title);
var title
// 선언을 전에 해도 title에는 undefined값이 들어간다.

var title = 'Codeit'
console.log(title)

var title = 'JavaScript'
console.log(title)
// 또한 중복선언이 가능하기때문에 위에 title=codeit은 사라지게된다는것

// 또한 var키워드는 지역변수를 만들기 어려우며 반복문 안에서도 선언해도 전역변수로 취급된다.
```
> let,const는 할당이전에 값이 오면 오류를 뱉어주고 , 중복선언이 불가하다.

자바스크립트에 {}로 감싸진 부분을 '코드블록'이라고 부른다. let,const는 중괄호안에 들어가있어도 스코프로 구분되기에(지역변수)

### **추가**
var은 함수 스코프를 가진다(function scope)
let은 블록 스코프 (block scope)
const은 블록 스코프 (block scope)
> var은 함수 내부에 써야 지역변수이고, 그 이외에는 전역변수라는 것

```js
function sayHi() {
	var userName = 'codeit'
	console.log(`Hi ${userName}!`);
}
console.log(userName) // ReferenceError
```

함수 호이스팅
```js
// function 이 선언되기전에 호출해도 되는데 이것은 함수가 위로 호이스팅 되었기때문이다.
// 함수선언은 변수의 var키워드 처럼 함수 스코프를 가진다. 해당 스코프내에 함수는 부모의 함수내부에서만 사용이 가능하다. 다만 for,while같은 문에서 사용이가능하다.
printCode();

function printCode() {
	console.log(';;;')
}

// 함수 표현식은 선언되기 전에 호출하면 에러가나타난다.
// 할당된 변수에 따라 스코프가 결정된다.
// 무조건 블록 스코프를 가리진 않는다. 어떤 변수가 할당되냐에 따라 다르다. 만약var키워드로 선언했다면 그 함수는 당연히 함수 스코프를 가지게된다.
//let,const선언시 블록 스코프 , vaf 선언시 함수 스코프
printCode(); // ReferenceError

const printCode = function() {
	console.log('...')
}
```

## 함수선언 vs 함수표현식
두 방식어느것을 해도 각자 장단점이 있고 문제없지만, 가갑적 둘 중 하나를 선택해서 최대한 일관된 방식으로 만드는것이 좋다.

일반적으로 개념을 설명할때는 함수표현식보다는 함수 선언이 보편적으로 사용됨
그래서 강의에서는 함수선언을 사용하게될것임

## 기명 함수 표현식(Named Function Expression)
함수 표현식으로 함수를 만들 때 선언하는 함수에 이름을 붙여줄수있는데, 이름이 있는 함수 표현식, 즉 **기명 함수 표현식**이라고 부른다.
```js
const sayHi = function() { //변수의 이름 함수는 이름이 없는상태
	console.log('Hi');
};

console.log(sayHi.name); //sayHi

// 이름이 없는 함수를 변수에 할당할 때는 변수의 name 프로퍼티는 변수 이름 그 자체를 문자열로 가지게 된다. 하지만 함수에 이름을 붙여주게 되면, name 속성은 함수 이름을 문자열로 갖게 된다.

const sayHi = function printHiInConsole() { //함수의 이름이있을경우
  console.log('Hi');
};

console.log(sayHi.name); // printHiInConsole
printHiInConsole(); // ReferenceError

// 이 함수 이름은 함수 내부에서 함수 자체를 가리킬 때 사용할 수 있고 함수를 외부에서 함수를 호출할 때 사용할수는 없습니다.
```

```js
let countdown = function(n) {
	console.log(n)

	if(n === 0) {
		console.log('End')
	} else {
		countdown(n-1)
	}
};

countdown(5)

// 값이 0이 될때까지 하나씩 값을 줄이면서 자기 자신을 호출하는 countdown이라는 함수를 표현식으로 작성
//이런식으로 다시 자기자신을 부르는 함수를 재귀함수(Recursive function)이라고한다.
```
```js
let countdown = function(n) {
  console.log(n);
  if (n === 0) {
    console.log('End!');
  } else {
    countdown(n - 1);
  }
};

let myFunction = countdown; //주소값 복사

countdown = null;

myFunction(5); // TypeError
// coundown함수가 null값으로 변경되었기에 함수가 아니라는 TypeError가 발생 (6번째줄)
```
> 이런 상황을 방지하기 위해 함수 내부에서 함수 자신을 사용하려고 하면 반드시 기명 함수 표현식을 사용하는것이 좋다.

```js
let countdown = function printCountdown(n) {
  console.log(n);
  if (n === 0) {
    console.log('End!');
  } else {
    printCountdown(n - 1);
  }
};

let myFunction = countdown; //주소값 복사

countdown = null;

myFunction(5); // 정상적으로 동작

```

## 결론
함수 표현식에는 함수에 이름을 지정가능함(함수 선언식처럼) 특히 위에 예처럼 함수내에서 함수를 가리켜야 할 때는 꼭 함수 이름을 작성해주는 것이 안전하다는 점이다. 

---
## 즉시 실행 함수(IIFE: Immediately Invoked Function Expression)
```js
(function() {
	console.log('Hi!)
})();

/** 일반 함수 선언처럼 파라미터를 작성하고, 함수를 호출시 아규먼트 전달가능 */
(function(x+y){
	console.log(x+y)
})(3,5)

/** 다만 외부에서는 함수에 이름을 지어주더라도 재사용할수없다. */
(function sayHi() {
	console.log('Hi!')
})();

sayHi(); //ReferenceError
```
> 함수선언 부를 소괄호로 감싼 다음 바로 뒤에 함수를 실행하는 소괄호를 한번 더붙여주는방식

다만 함수 내부에서 자기자신을 호출하는 재귀적인 구조를 만들고자 할땐 이름이 필요할수도있다.(기명함수표현식 참고)

```js
(function countdown(n){
	console.log(n)
	if(n===0) {
		console.log('end')
	} else {
		countdown(n - 1)
	}
})(5)
```

## IIFE 즉시 실행 함수 활용
즉시 실행 함수는 선언과 동시에 실행이 이뤄지기에 일반적으로 프로그램 **초기화 기능**에 많이 활용된다.
```js
(function init() {
	// 프로그램이 실행 될 때 기본적으로 동작할 코드들;
})();
```

재사용이 필요없는, 일회성 동작에
```js
const firstName = 'Young';
const lastName = 'Kang';

const greetingMessage = (fuction(){
	const fullName = `${firstName} + ${lastName}`;

	return `Hi! My name is ${fullName}`;
})();
// 함수의 리턴값을 바로 변수에 할당하고 싶을 때 활용할 수 있다.
```
